<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Datenbanken on isiko404's Homepage</title><link>https://isiko.github.io/tags/datenbanken/</link><description>Recent content in Datenbanken on isiko404's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 07 Mar 2022 00:00:00 +0100</lastBuildDate><atom:link href="https://isiko.github.io/tags/datenbanken/index.xml" rel="self" type="application/rss+xml"/><item><title>Daten und ihre Strukturierung</title><link>https://isiko.github.io/projects/abitur/computer-science/datenundstrukturen/</link><pubDate>Mon, 07 Mar 2022 00:00:00 +0100</pubDate><guid>https://isiko.github.io/projects/abitur/computer-science/datenundstrukturen/</guid><description>Objekte und Klassen Diagramme Um beim schreiben von Software eine grobe Idee zu haben was man eigendlich Machen muss ist es Sinnvoll eine grobe Idee zu haben was man macht. Dazu hat die Informatik sich einige Diagramme überlegt, und das Abitur in NRW hat sogar noch eins mehr! Im folgenden möchte ich einen Überblick über die verschiedenen Diagramme geben, wobei ich sie in der Reihenfolge vorstelle in der sie normalerweise erstellt werden.</description><content>&lt;h1 id="objekte-und-klassen">Objekte und Klassen&lt;/h1>
&lt;h2 id="diagramme">Diagramme&lt;/h2>
&lt;p>Um beim schreiben von Software eine grobe Idee zu haben was man eigendlich Machen muss ist es Sinnvoll eine grobe Idee zu haben was man macht. Dazu hat die Informatik sich einige Diagramme überlegt, und das Abitur in NRW hat sogar noch eins mehr! Im folgenden möchte ich einen Überblick über die verschiedenen Diagramme geben, wobei ich sie in der Reihenfolge vorstelle in der sie normalerweise erstellt werden.&lt;/p>
&lt;h3 id="objektdiagramm">Objektdiagramm&lt;/h3>
&lt;ul>
&lt;li>Beschreibt einen Zustand des Programms
&lt;ul>
&lt;li>Konkrete Werte für Attribute&lt;/li>
&lt;li>keine Methoden&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Alle Objekte mit Runden Ecken&lt;/li>
&lt;li>Pfeile für Interaktionen zwischen den Objekten&lt;/li>
&lt;/ul>
&lt;h3 id="klassendiagramme">Klassendiagramme&lt;/h3>
&lt;p>Alle Objekte müssen einer Klasse zugehören, wesshalb auch hierfür Diagramme notwendig sind.&lt;/p>
&lt;h4 id="klassentypen">Klassentypen&lt;/h4>
&lt;p>Klasse ist nicht unbedingt gleich Klasse, es gibt 2 wichtige Merkmale die sie aufweisen können:&lt;/p>
&lt;ul>
&lt;li>Interfaces
&lt;ul>
&lt;li>Interfaces haben keine Attribute&lt;/li>
&lt;li>Methoden sind nur mit Methodenkopf angegeben&lt;/li>
&lt;li>Es kann nicht dierekt ein Objekt von ihnen erstellt werden, nur ihre Unterklassen können instanziiert werden&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="beziehungen">Beziehungen&lt;/h4>
&lt;p>Klassen stehen meist in Beziehungen mit anderen Klassen, gekennzeichnet durch verschiedene Arten von Pfeilen. Im folgenden werde ich versuchen alle zu erklären, wobei ich immer von &lt;code>A -&amp;gt; B&lt;/code> ausgehen werde&lt;/p>
&lt;ul>
&lt;li>Assoziation
&lt;ul>
&lt;li>Bedeutung: Objekte der Klasse &lt;code>A&lt;/code> können auch eine bestimmte anzahl an Objekten der Klasse &lt;code>B&lt;/code> zugreifen&lt;/li>
&lt;li>gekennzeichnet durch einen einfachen Pfeil&lt;/li>
&lt;li>Kardinalität
&lt;ul>
&lt;li>Indikator der Anzahl an Objekten der Klasse &lt;code>B&lt;/code> die von einem Objekt der Klasse &lt;code>A&lt;/code> zugegriffen werden kann. (meist entweder 0 oder 0..n)&lt;/li>
&lt;li>Steht bei der Pfeilspitze&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Haben einen Namen&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Vererbung
&lt;ul>
&lt;li>Bedeutung: Jeglicher Code der Klasse &lt;code>B&lt;/code> wird auch der Klasse &lt;code>A&lt;/code> zur verfügung gestellt&lt;/li>
&lt;li>Dargestellt duch einen Pfeil mit einem nicht ausgefüllten Dreieck als Spitze
&lt;ul>
&lt;li>Beim erben von einem Interface wird der Pfeil gestrichelt gezeichnet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Wichtig: Pfeil geht von der Unteklasse zur Superklasse&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="entwurfsdiagramm">Entwurfsdiagramm&lt;/h3>
&lt;ul>
&lt;li>Beschreibt alle Klassen des späteren Programms
&lt;ul>
&lt;li>Inhalte für jede Klassen:
&lt;ul>
&lt;li>Klassenname&lt;/li>
&lt;li>Attribute (mit Pseudodatentyp)&lt;/li>
&lt;li>Methoden (mit Pseudodatentyp)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Selbst Bibliotheken müssen theoretisch mit aufgezeichnet werden (siehe z.B. Stack, Queue, &amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Komplett unabhängig von Programm Code
&lt;ul>
&lt;li>Datentypen NICHT wie in Java, stattdessen andere Namen:
&lt;ul>
&lt;li>Integer =&amp;gt; Zahl&lt;/li>
&lt;li>String =&amp;gt; Text&lt;/li>
&lt;li>Boolean =&amp;gt; Wahrheitswert&lt;/li>
&lt;li>Stack/Queue/List/&amp;hellip; =&amp;gt; Datensammlung&amp;lt;&amp;gt;
&lt;ul>
&lt;li>in den spitzen Klammern steht hier der Datentyp der Elemente&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="implementationsdiagramm">Implementationsdiagramm&lt;/h3>
&lt;ul>
&lt;li>Präzisierung der Entwurfsdiagramms&lt;/li>
&lt;li>Näher an der verwendeten Programmiersprache&lt;/li>
&lt;li>Verwendet echt Datentypen anstelle von Pseudodatentypen&lt;/li>
&lt;li>Markierung von Interfaces und Abstrakten Klassen
&lt;ul>
&lt;li>Interfaces
&lt;ul>
&lt;li>Interfaces haben keine Attribute&lt;/li>
&lt;li>Methoden sind nur mit Methodenkopf angegeben&lt;/li>
&lt;li>Es kann nicht dierekt ein Objekt von ihnen erstellt werden, nur ihre Unterklassen können instanziiert werden&lt;/li>
&lt;li>Im Implementationsdiagramm wird über den Klassennamen mittig &lt;code>&amp;lt;&amp;lt;inteface&amp;gt;&amp;gt;&lt;/code> geschrieben&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Abstrakte Klassen
&lt;ul>
&lt;li>Sind als Schablone für ander ähnliche Klassen zu verstehen
&lt;ul>
&lt;li>Bsp. Fahrzeug als Abstrakte Klasse und Auto oder Roller als Unterklassen&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Es kann nicht direkt ein Objekt von ihnen erstellt werden, nur ihre Unterklassen können instanziiert werden&lt;/li>
&lt;li>Im Implementatinsdiagramm wird unter den Klassennamen rechts &lt;code>{{abstract}}&lt;/code> geschrieben&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>gängige Konzepte wie Listen, Stacks oder Queues können müssen nicht mit Attributen und Methoden aufgeschrieben werden, es reicht der Klassenname
&lt;ul>
&lt;li>Hier muss aber der Contenttype angegeben werden&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="struktogramme">Struktogramme&lt;/h3>
&lt;p>Kommt noch&lt;/p>
&lt;h2 id="lineare-strukturen">Lineare Strukturen&lt;/h2>
&lt;p>(Dokumentation wird in der Klausur bereitgestellt)&lt;/p>
&lt;ul>
&lt;li>Stack&lt;/li>
&lt;li>Queue&lt;/li>
&lt;li>List&lt;/li>
&lt;/ul>
&lt;h2 id="nicht-lineare-strukturen">Nicht-Lineare Strukturen&lt;/h2>
&lt;p>(Dokumentation wird in der Klausur bereitgestellt)&lt;/p>
&lt;ul>
&lt;li>Binary Tree&lt;/li>
&lt;li>Binary Search Tree&lt;/li>
&lt;li>Graph&lt;/li>
&lt;/ul>
&lt;h1 id="datenbanken">Datenbanken&lt;/h1>
&lt;p>Datenbanken sind ein einfacher zentraler Massenspeicher der von mehreren Programmen gleichzeitig genutzt werden kann.&lt;/p>
&lt;h2 id="modelierung">Modelierung&lt;/h2>
&lt;p>Kommt noch&lt;/p>
&lt;h2 id="anomalien">Anomalien&lt;/h2>
&lt;p>Durch das verändern der Datenbank kann es sein das sie Fehlerhaft wird. Diese &lt;code>Anomalien&lt;/code> können teilweise durch kluges Modelieren vermieden werden. Gegen mutwillige zerstörung hilft das aber auch nicht.&lt;/p>
&lt;h3 id="arten">Arten&lt;/h3>
&lt;ul>
&lt;li>Löschanomalien&lt;/li>
&lt;li>Eingügeanomalien&lt;/li>
&lt;li>Aktualisierungsanomalien&lt;/li>
&lt;/ul>
&lt;h3 id="normalisierung">Normalisierung&lt;/h3>
&lt;ol>
&lt;li>Ein Wert pro Zelle&lt;/li>
&lt;li>Die Primärschlüssel sind Abhängig voneinander - Jedes Nicht-Schlüsselattribut ist &lt;code>voll funktional abhängig&lt;/code> von Primärschlüssel&lt;/li>
&lt;li>Aus keinem Nicht-Schlüsselattribut folgt ein anderes Nicht-Schlüsselattribut
&lt;ul>
&lt;li>Jedes Nicht-Schlüsselattribut ist &lt;code>nicht transitiv&lt;/code> vom Primärschlüssel &lt;code>abhängig&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="sql">SQL&lt;/h2>
&lt;h3 id="statements">Statements&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SELECT&lt;/code> spalten &lt;code>AS&lt;/code> alias &lt;code>FROM&lt;/code> tabelle&lt;/p>
&lt;ul>
&lt;li>&lt;code>GROUP BY&lt;/code> spalte
&lt;ul>
&lt;li>Zusammenfassung von Zeilen, deren Wert in der angegebenen Spalte gleich ist&lt;/li>
&lt;li>Abgesehen von der angegebenen Spalte sollten nur Funktionen als Spalten angegeben werden&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ORDER BY&lt;/code> spalte1, spalte2, &amp;hellip; ((&lt;code>ASC&lt;/code> / &lt;code>DESC&lt;/code>))
&lt;ul>
&lt;li>Zeilen werden nach ihren werten in den angegebenen Spalten sortiert&lt;/li>
&lt;li>&lt;code>ASC&lt;/code> = Aufsteigend&lt;/li>
&lt;li>&lt;code>DESC&lt;/code> = Abstiegend (Standard)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>((&lt;code>LEFT&lt;/code>/&lt;code>RIGHT&lt;/code>/&lt;code>INNER&lt;/code>)) &lt;code>JOIN&lt;/code> &amp;hellip; &lt;code>ON&lt;/code> tabelle1.spalte1 = tabelle2.spalte2
&lt;ul>
&lt;li>Kombiniert 2 tabellen und gibt die spalten zurück in denen die &lt;code>ON&lt;/code> Bedingung erfüllt ist oder die ein anderes Kriterium erfüllen&lt;/li>
&lt;li>&lt;code>INNER&lt;/code> = Gibt nur die Spalten zurück, die die Bedingung erfüllen&lt;/li>
&lt;li>&lt;code>LEFT (OUTER)&lt;/code> = Wie &lt;code>INNER&lt;/code>, nur das egal ob die Bedingung erfüllt ist alle Spalten der 1. genannten Tabelle ausgegeben werden&lt;/li>
&lt;li>&lt;code>RIGHT (OUTER)&lt;/code> = Wie &lt;code>INNER&lt;/code>, nur das egal ob die Bedingung erfüllt ist alle Spalten der 2. genannten Tabelle ausgegeben werden&lt;/li>
&lt;li>&lt;code>FULL (OUTER)&lt;/code> = Alle Spalten werden ausgegeben&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>UNION&lt;/code>
&lt;ul>
&lt;li>Setzt die jede n-te Spalte der 2. Tabelle unter die n-te Spalte der 1. Tabelle&lt;/li>
&lt;li>Standardmäßig werden doppelte Zeilen rausgefiltert
&lt;ul>
&lt;li>kann durch &lt;code>UNION ALL&lt;/code> deaktiviert werden&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>DELETE FROM&lt;/code> tabelle &lt;code>WHERE&lt;/code> bedingung&lt;/p>
&lt;ul>
&lt;li>Das WHERE statement kann auch weggelassen werden, dann werden einfach alle einträge der tabelle gelöscht&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>INSERT INTO&lt;/code> tabelle (spalte1, spalte2, &amp;hellip;) &lt;code>VALUES&lt;/code> (wert1, wert2, &amp;hellip;)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>UPDATE&lt;/code> tabelle &lt;code>SET&lt;/code> spalte1 = wert1, spalte2 = wert2, &amp;hellip; &lt;code>WHERE&lt;/code> bedingung&lt;/p>
&lt;ul>
&lt;li>Das WHERE statement kann auch weggelassen werden, dann werden die operationen auf alle werte ausgeführt&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="besondere-vergleichsoperatoren">Besondere Vergleichsoperatoren&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Beispiel&lt;/th>
&lt;th>Beschreibung&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>a &lt;code>&amp;lt;&amp;gt;&lt;/code> b&lt;/td>
&lt;td>Ungleich&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a &lt;code>LIKE&lt;/code> b&lt;/td>
&lt;td>Pattern Matching (% = egal wie viele undefinierte chars&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a &lt;code>BETWEEN&lt;/code> b &lt;code>AND&lt;/code> c&lt;/td>
&lt;td>Testet ob &lt;code>a&lt;/code> in der range von &lt;code>b&lt;/code> - &lt;code>c&lt;/code> ist&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a &lt;code>IN&lt;/code> (geschachtelte SQL abfrage)&lt;/td>
&lt;td>Testet ob &lt;code>a&lt;/code> in den Ergebnissen der geschachtelten Abfrage ist&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a &lt;code>IS&lt;/code> &lt;code>NULL&lt;/code>&lt;/td>
&lt;td>Testet ob der &lt;code>a&lt;/code> nicht definiert ist&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="funktionen">Funktionen&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Funktionsname&lt;/th>
&lt;th>Beschreibung&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>COUNT&lt;/code>&lt;/td>
&lt;td>Gibt die Anzahl der Zeilen wieder&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SUM&lt;/code>&lt;/td>
&lt;td>Gibt die Summe aller werte einer Spalte wieder&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>MAX&lt;/code>&lt;/td>
&lt;td>Gibt den Minimalwert in einer Spalte wieder&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>MIN&lt;/code>&lt;/td>
&lt;td>Gibt den Maximalwert in einer Spalte wieder&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>AVG&lt;/code>&lt;/td>
&lt;td>Gibt den Durchschnittswert einer Spalte wieder&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kommt noch&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></content></item></channel></rss>