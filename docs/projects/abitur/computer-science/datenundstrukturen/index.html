<!doctype html><html lang=en><head><title>Daten und ihre Strukturierung :: isiko404's Homepage</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Diagramme, Datenbanken"><meta name=keywords content="abitur,a-levels,computer-science,Informatik"><meta name=robots content="noodp"><link rel=canonical href=https://isiko.github.io/projects/abitur/computer-science/datenundstrukturen/><link rel=stylesheet href=https://isiko.github.io/assets/style.css><link rel=stylesheet href=https://isiko.github.io/assets/c101.css><link rel=apple-touch-icon href=https://isiko.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://isiko.github.io/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="isi_ko404"><meta name=twitter:creator content="isi_ko404"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Daten und ihre Strukturierung"><meta property="og:description" content="Diagramme, Datenbanken"><meta property="og:url" content="https://isiko.github.io/projects/abitur/computer-science/datenundstrukturen/"><meta property="og:site_name" content="isiko404's Homepage"><meta property="og:image" content="https://isiko.github.io/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-03-07 00:00:00 +0100 +0100"></head><body class=c101><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>isi_ko404</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>about</a></li><li><a href=/contact>contact</a></li><li><a href=/projects>projects</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>about</a></li><li><a href=/contact>contact</a></li><li><a href=/projects>projects</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://isiko.github.io/projects/abitur/computer-science/datenundstrukturen/>Daten und ihre Strukturierung</a></h1><div class=post-meta><span class=post-date>2022-03-07</span></div><span class=post-tags>#<a href=https://isiko.github.io/tags/school/>school</a>&nbsp;
#<a href=https://isiko.github.io/tags/computer-science/>computer-science</a>&nbsp;
#<a href=https://isiko.github.io/tags/datenbanken/>Datenbanken</a>&nbsp;
#<a href=https://isiko.github.io/tags/diagramme/>Diagramme</a>&nbsp;</span><div class=post-content><div><h1 id=objekte-und-klassen>Objekte und Klassen<a href=#objekte-und-klassen class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=diagramme>Diagramme<a href=#diagramme class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Um beim schreiben von Software eine grobe Idee zu haben was man eigendlich Machen muss ist es Sinnvoll eine grobe Idee zu haben was man macht. Dazu hat die Informatik sich einige Diagramme überlegt, und das Abitur in NRW hat sogar noch eins mehr! Im folgenden möchte ich einen Überblick über die verschiedenen Diagramme geben, wobei ich sie in der Reihenfolge vorstelle in der sie normalerweise erstellt werden.</p><h3 id=objektdiagramm>Objektdiagramm<a href=#objektdiagramm class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Beschreibt einen Zustand des Programms<ul><li>Konkrete Werte für Attribute</li><li>keine Methoden</li></ul></li><li>Alle Objekte mit Runden Ecken</li><li>Pfeile für Interaktionen zwischen den Objekten</li></ul><h3 id=klassendiagramme>Klassendiagramme<a href=#klassendiagramme class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Alle Objekte müssen einer Klasse zugehören, wesshalb auch hierfür Diagramme notwendig sind.</p><h4 id=klassentypen>Klassentypen<a href=#klassentypen class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Klasse ist nicht unbedingt gleich Klasse, es gibt 2 wichtige Merkmale die sie aufweisen können:</p><ul><li>Interfaces<ul><li>Interfaces haben keine Attribute</li><li>Methoden sind nur mit Methodenkopf angegeben</li><li>Es kann nicht dierekt ein Objekt von ihnen erstellt werden, nur ihre Unterklassen können instanziiert werden</li></ul></li></ul><h4 id=beziehungen>Beziehungen<a href=#beziehungen class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Klassen stehen meist in Beziehungen mit anderen Klassen, gekennzeichnet durch verschiedene Arten von Pfeilen. Im folgenden werde ich versuchen alle zu erklären, wobei ich immer von <code>A -> B</code> ausgehen werde</p><ul><li>Assoziation<ul><li>Bedeutung: Objekte der Klasse <code>A</code> können auch eine bestimmte anzahl an Objekten der Klasse <code>B</code> zugreifen</li><li>gekennzeichnet durch einen einfachen Pfeil</li><li>Kardinalität<ul><li>Indikator der Anzahl an Objekten der Klasse <code>B</code> die von einem Objekt der Klasse <code>A</code> zugegriffen werden kann. (meist entweder 0 oder 0..n)</li><li>Steht bei der Pfeilspitze</li></ul></li><li>Haben einen Namen</li></ul></li><li>Vererbung<ul><li>Bedeutung: Jeglicher Code der Klasse <code>B</code> wird auch der Klasse <code>A</code> zur verfügung gestellt</li><li>Dargestellt duch einen Pfeil mit einem nicht ausgefüllten Dreieck als Spitze<ul><li>Beim erben von einem Interface wird der Pfeil gestrichelt gezeichnet</li></ul></li><li>Wichtig: Pfeil geht von der Unteklasse zur Superklasse</li></ul></li></ul><h3 id=entwurfsdiagramm>Entwurfsdiagramm<a href=#entwurfsdiagramm class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Beschreibt alle Klassen des späteren Programms<ul><li>Inhalte für jede Klassen:<ul><li>Klassenname</li><li>Attribute (mit Pseudodatentyp)</li><li>Methoden (mit Pseudodatentyp)</li></ul></li><li>Selbst Bibliotheken müssen theoretisch mit aufgezeichnet werden (siehe z.B. Stack, Queue, &mldr;)</li></ul></li><li>Komplett unabhängig von Programm Code<ul><li>Datentypen NICHT wie in Java, stattdessen andere Namen:<ul><li>Integer => Zahl</li><li>String => Text</li><li>Boolean => Wahrheitswert</li><li>Stack/Queue/List/&mldr; => Datensammlung&lt;><ul><li>in den spitzen Klammern steht hier der Datentyp der Elemente</li></ul></li></ul></li></ul></li></ul><h3 id=implementationsdiagramm>Implementationsdiagramm<a href=#implementationsdiagramm class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Präzisierung der Entwurfsdiagramms</li><li>Näher an der verwendeten Programmiersprache</li><li>Verwendet echt Datentypen anstelle von Pseudodatentypen</li><li>Markierung von Interfaces und Abstrakten Klassen<ul><li>Interfaces<ul><li>Interfaces haben keine Attribute</li><li>Methoden sind nur mit Methodenkopf angegeben</li><li>Es kann nicht dierekt ein Objekt von ihnen erstellt werden, nur ihre Unterklassen können instanziiert werden</li><li>Im Implementationsdiagramm wird über den Klassennamen mittig <code>&lt;&lt;inteface>></code> geschrieben</li></ul></li><li>Abstrakte Klassen<ul><li>Sind als Schablone für ander ähnliche Klassen zu verstehen<ul><li>Bsp. Fahrzeug als Abstrakte Klasse und Auto oder Roller als Unterklassen</li></ul></li><li>Es kann nicht direkt ein Objekt von ihnen erstellt werden, nur ihre Unterklassen können instanziiert werden</li><li>Im Implementatinsdiagramm wird unter den Klassennamen rechts <code>{{abstract}}</code> geschrieben</li></ul></li></ul></li><li>gängige Konzepte wie Listen, Stacks oder Queues können müssen nicht mit Attributen und Methoden aufgeschrieben werden, es reicht der Klassenname<ul><li>Hier muss aber der Contenttype angegeben werden</li></ul></li></ul><h3 id=struktogramme>Struktogramme<a href=#struktogramme class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Kommt noch</p><h2 id=lineare-strukturen>Lineare Strukturen<a href=#lineare-strukturen class=hanchor arialabel=Anchor>&#8983;</a></h2><p>(Dokumentation wird in der Klausur bereitgestellt)</p><ul><li>Stack</li><li>Queue</li><li>List</li></ul><h2 id=nicht-lineare-strukturen>Nicht-Lineare Strukturen<a href=#nicht-lineare-strukturen class=hanchor arialabel=Anchor>&#8983;</a></h2><p>(Dokumentation wird in der Klausur bereitgestellt)</p><ul><li>Binary Tree</li><li>Binary Search Tree</li><li>Graph</li></ul><h1 id=datenbanken>Datenbanken<a href=#datenbanken class=hanchor arialabel=Anchor>&#8983;</a></h1><p>Datenbanken sind ein einfacher zentraler Massenspeicher der von mehreren Programmen gleichzeitig genutzt werden kann.</p><h2 id=modelierung>Modelierung<a href=#modelierung class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Kommt noch</p><h2 id=anomalien>Anomalien<a href=#anomalien class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Durch das verändern der Datenbank kann es sein das sie Fehlerhaft wird. Diese <code>Anomalien</code> können teilweise durch kluges Modelieren vermieden werden. Gegen mutwillige zerstörung hilft das aber auch nicht.</p><h3 id=arten>Arten<a href=#arten class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Löschanomalien</li><li>Eingügeanomalien</li><li>Aktualisierungsanomalien</li></ul><h3 id=normalisierung>Normalisierung<a href=#normalisierung class=hanchor arialabel=Anchor>&#8983;</a></h3><ol><li>Ein Wert pro Zelle</li><li>Die Primärschlüssel sind Abhängig voneinander - Jedes Nicht-Schlüsselattribut ist <code>voll funktional abhängig</code> von Primärschlüssel</li><li>Aus keinem Nicht-Schlüsselattribut folgt ein anderes Nicht-Schlüsselattribut<ul><li>Jedes Nicht-Schlüsselattribut ist <code>nicht transitiv</code> vom Primärschlüssel <code>abhängig</code>.</li></ul></li></ol><h2 id=sql>SQL<a href=#sql class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=statements>Statements<a href=#statements class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><p><code>SELECT</code> spalten <code>AS</code> alias <code>FROM</code> tabelle</p><ul><li><code>GROUP BY</code> spalte<ul><li>Zusammenfassung von Zeilen, deren Wert in der angegebenen Spalte gleich ist</li><li>Abgesehen von der angegebenen Spalte sollten nur Funktionen als Spalten angegeben werden</li></ul></li><li><code>ORDER BY</code> spalte1, spalte2, &mldr; ((<code>ASC</code> / <code>DESC</code>))<ul><li>Zeilen werden nach ihren werten in den angegebenen Spalten sortiert</li><li><code>ASC</code> = Aufsteigend</li><li><code>DESC</code> = Abstiegend (Standard)</li></ul></li><li>((<code>LEFT</code>/<code>RIGHT</code>/<code>INNER</code>)) <code>JOIN</code> &mldr; <code>ON</code> tabelle1.spalte1 = tabelle2.spalte2<ul><li>Kombiniert 2 tabellen und gibt die spalten zurück in denen die <code>ON</code> Bedingung erfüllt ist oder die ein anderes Kriterium erfüllen</li><li><code>INNER</code> = Gibt nur die Spalten zurück, die die Bedingung erfüllen</li><li><code>LEFT (OUTER)</code> = Wie <code>INNER</code>, nur das egal ob die Bedingung erfüllt ist alle Spalten der 1. genannten Tabelle ausgegeben werden</li><li><code>RIGHT (OUTER)</code> = Wie <code>INNER</code>, nur das egal ob die Bedingung erfüllt ist alle Spalten der 2. genannten Tabelle ausgegeben werden</li><li><code>FULL (OUTER)</code> = Alle Spalten werden ausgegeben</li></ul></li><li><code>UNION</code><ul><li>Setzt die jede n-te Spalte der 2. Tabelle unter die n-te Spalte der 1. Tabelle</li><li>Standardmäßig werden doppelte Zeilen rausgefiltert<ul><li>kann durch <code>UNION ALL</code> deaktiviert werden</li></ul></li></ul></li></ul></li><li><p><code>DELETE FROM</code> tabelle <code>WHERE</code> bedingung</p><ul><li>Das WHERE statement kann auch weggelassen werden, dann werden einfach alle einträge der tabelle gelöscht</li></ul></li><li><p><code>INSERT INTO</code> tabelle (spalte1, spalte2, &mldr;) <code>VALUES</code> (wert1, wert2, &mldr;)</p></li><li><p><code>UPDATE</code> tabelle <code>SET</code> spalte1 = wert1, spalte2 = wert2, &mldr; <code>WHERE</code> bedingung</p><ul><li>Das WHERE statement kann auch weggelassen werden, dann werden die operationen auf alle werte ausgeführt</li></ul></li></ul><h3 id=besondere-vergleichsoperatoren>Besondere Vergleichsoperatoren<a href=#besondere-vergleichsoperatoren class=hanchor arialabel=Anchor>&#8983;</a></h3><table><thead><tr><th>Beispiel</th><th>Beschreibung</th></tr></thead><tbody><tr><td>a <code>&lt;></code> b</td><td>Ungleich</td></tr><tr><td>a <code>LIKE</code> b</td><td>Pattern Matching (% = egal wie viele undefinierte chars</td></tr><tr><td>a <code>BETWEEN</code> b <code>AND</code> c</td><td>Testet ob <code>a</code> in der range von <code>b</code> - <code>c</code> ist</td></tr><tr><td>a <code>IN</code> (geschachtelte SQL abfrage)</td><td>Testet ob <code>a</code> in den Ergebnissen der geschachtelten Abfrage ist</td></tr><tr><td>a <code>IS</code> <code>NULL</code></td><td>Testet ob der <code>a</code> nicht definiert ist</td></tr></tbody></table><h3 id=funktionen>Funktionen<a href=#funktionen class=hanchor arialabel=Anchor>&#8983;</a></h3><table><thead><tr><th>Funktionsname</th><th>Beschreibung</th></tr></thead><tbody><tr><td><code>COUNT</code></td><td>Gibt die Anzahl der Zeilen wieder</td></tr><tr><td><code>SUM</code></td><td>Gibt die Summe aller werte einer Spalte wieder</td></tr><tr><td><code>MAX</code></td><td>Gibt den Minimalwert in einer Spalte wieder</td></tr><tr><td><code>MIN</code></td><td>Gibt den Maximalwert in einer Spalte wieder</td></tr><tr><td><code>AVG</code></td><td>Gibt den Durchschnittswert einer Spalte wieder</td></tr><tr><td>Kommt noch</td><td></td></tr></tbody></table></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://isiko.github.io/projects/abitur/computer-science/automatentheorie/><span class=button__icon>←</span>
<span class=button__text>Automatentheorie</span></a></span>
<span class="button next"><a href=https://isiko.github.io/projects/abitur/computer-science/graphentheorie/><span class=button__text>Graphentheorie</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://isiko.github.io/assets/main.js></script>
<script src=https://isiko.github.io/assets/prism.js></script></div></body></html>